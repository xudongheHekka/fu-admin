uid_str = "10876645,11209576,10876632,10876642,11209562,10876627,10876661,10876647,11210041,11209995,10876640,11209557,10876361,11209556,10787472,11209512,10876502,10876408,11209563,11209812,10876588,10876222,11209587,10876631,11209567,10876559,10876504,11209584,10876452,11209635,10876569,10876662,10876373,10876530,10876328,11209839,10876500,4434889,3527877,10876609,10876267,10876270,10876487,10876337,10876430,10876347,10876596,11209573,10876213,11209618,10876335,10876228,10876397,10876409,11209988,10876602,10876403,10876383,11209899,10876421,11210096,10876249,11209775,11210064,10876687,11210090,10876351,10876689,11209606,10876707,10876978,11209544,10876562,10876350,10876480,11209721,10876388,11209884,10876555,11210076,10876583,11209582,10876345,11209848,11209996,11209654,10876507,11209912,10876656,11209850,10876762,11209870,11210029,11209772,11209630,11209845,11210013,11209797,11209620,11210030,11210101,11209718,11209824,10876550,11209823,11210010,11209597,10876338,10876683,10876463,10876603,11209616,11209773,11209810,10876524,10876257,11209785,10876247,11209750,10876479,11209626,11209897,10876429,10876445,10876478,10876665,11210069,11209636,10876370,10876339,11209736,11209986,11209651,10876724,10876668,10876410,11210080,11210093,11209771,10876591,11209652,11210002,11209826,10876621,11210070,11210049,11209546,11209893,10876741,11209792,10876705,10876786,11209744,11209742,10876581,11209543,11209628,11209818,11210012,10876396,10876441,11210048,11209533,11209727,10876691,11209613,10876385,10876521,10876744,10876605,10876652,11209523,11209728,11209622,10876680,11209719,10876404,11209632,10876513,11209595,11210066,10876574,11209639,11209781,11210081,11210094,10876634,10876377,11209869,10876241,10876437,11209538,10876497,11209642,10876620,11209895,10876231,11209529,11209564,10876425,11210019,11209600,11209604,11209774,10876531,11209548,11209814,10876343,10876382,11209649,11209627,11209745,11209950,11209789,10876696,10787566,10876254,11209634,11209816,11209804,10876367,11210062,11209982,10876613,11210005,11209609,10876378,10876433,11209653,10876553,11209752,10876575,11209534,11209953,10876459,11209872,10876365,11209917,11209984,11209948,10876606,11209770,11209608,11209515,10876571,11209553,10876607,11209879,10876535,11209813,11210043,11209648,10876243,10876333,10876245,10876970,11209907,11209778,11209808,11209629,10876789,10876564,11210024,11209720,11209934,11209625,10876616,11209866,10876363,11210099,10700301,10683240,10876793,7071509,10876330,10876475,11209821,11209754,10876380,10876694,10876590,11210007,10876560,10876375,10876255,11209880,11209882,11209838,11209769,10876438,10876686,10876516,10876675,11209840,10876677,11209947,11209550,10876412,10876400,10876577,11209566,10876643,10876658,10876519,10876641,10876838,10876357,10876597,10876649,11209561,11209586,10876458,10876444,10876636,10876844,11209545,11209565,10876527,11209531,10876332,10876646,11209558,11210003,11209575,10876576,10876628,10410388,11209637,10185257,11209552,10876465,10876651,11209555,11209585,10876558,10585795,10681328,10877062,10876639,10876391,10876644,10876648,10876348,10876654,10876679,11209559,10876499,10876269,10876489,10876493,10876488,10876271,11209998,10876885,10876871,11209815,10876520,11209560,11209578,10787359,11209711,10877003,10876791,11209594,11210008,11209938,10876761,11209571,10876943,11209670,10876948,11209540,10876947,11209864,10876469,10876716,11209579,11210027,10876635,10876601,11209737,10876424,10876889,10877051,10876376,10876972,10877014,10876392,11209676,10877045,10876490,11209795,10876374,10876473,10876897,10877066,10876915,10877077,10876788,10877068,11209990,11209596,11209583,10876670,10876608,10876824,10876442,10877058,11209963,10876501,10876739,10876863,10876790,10876923,11210053,11209647,11209908,11210067,10876580,10876809,11209787,10877000,10876448,10876782,11210052,10876905,10876394,11209999,11210015,10876913,10876259,11209964,11209656,10876881,10876618,10876693,10876812,10876964,11209599,11210102,10876892,10876667,10876223,10876354,11209945,10876399,10876485,10876787,11209519,11209847,11209699,10876894,10876870,10877076,10877028,10876842,10876470,11209876,11209674,10876912,11210047,11209621,10876857,10876922,10876867,11209551,11209901,10787567,11209717,11209521,11209532,10876811,10876921,11209708,11210057,10876614,10876880,10876785,11209655,11210033,11209692,11209958,11209807,10876714,10876733,11209598,10876406,10877038,10876803,10876678,11209881,11210091,10876831,10877007,11209985,10876460,10876704,11210004,10876719,10876671,10876910,10876422,11209715,10876882,11209530,10877085,10876364,10876834,11210056,10876983,10876991,10877033,11209765,11209640,10876723,10876589,10876988,10876895,10876248,11210025,10876925,11209581,10877064,11209592,10876936,11210065,11209614,10876956,10876563,10876884,10876759,10877012,10877063,11210110,10876990,10876509,11209878,11209516,11209867,10876466,10876240,10876258,10876768,11209940,10876953,10876823,11210034,11209883,10876751,11209524,10876402,11209791,10876623,10876669,10877043,11210039,10876708,10876850,10876703,11209607,11209709,11209589,10876801,10877042,11209902,10876434,10876341,10876548,10876579,10876384,10877086,11210079,10876977,10876800,10876529,11210087,11209991,11209661,10876810,11210092,10876989,11209536,11209677,11209577,10876969,11209777,10876660,10876512,10876663,10876847,10877029,10876931,10876549,10876934,11209685,10876945,10876930,11209766,11209680,10876536,10876538,11209660,11209638,10876518,10876227,10876547,10877050,10876815,10876584"


import json
import time
import hashlib
import base64
import requests
import threading
import concurrent.futures
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from collections import defaultdict
import statistics
from datetime import datetime


class BottleAPI:
    # 测试环境
    TOKEN_KEY = b'358d71c554ae78914fece40609aad77b'
    TOKEN_IV = b'F3a22EcceB2e0t13'
    CONTENT_KEY = b'75fa6cf7300033b477f5644110b8fcd7'
    CONTENT_IV = b'907AcdEf2fCb17fb'

    @staticmethod
    def encrypt(text: str, key: bytes, iv: bytes) -> str:
        """AES CBC 模式加密"""
        try:
            text = text.encode('utf-8')
            cipher = AES.new(key, AES.MODE_CBC, iv)
            encrypted = cipher.encrypt(pad(text, AES.block_size))
            return base64.b64encode(encrypted).decode('utf-8')
        except Exception as e:
            print(f"❌ 加密错误: {e}")
            return None

    @staticmethod
    def decrypt(encrypted_text: str, key: bytes, iv: bytes) -> str:
        """AES CBC 模式解密"""
        try:
            encrypted = base64.b64decode(encrypted_text)
            cipher = AES.new(key, AES.MODE_CBC, iv)
            decrypted = unpad(cipher.decrypt(encrypted), AES.block_size)
            return decrypted.decode('utf-8')
        except Exception as e:
            print(f"❌ 解密错误: {e}")
            return None

    def send_message(self, uid, request_id=None):
        if request_id is None:
            request_id = int(time.time() * 1000000) % 1000000

        # 记录开始时间
        start_time = time.time()
        current_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        print(f"[{current_time}] 🚀 请求#{request_id:06d} 开始 | UID: {uid}")

        try:
            # 加密token
            token = json.dumps({"uid": uid})
            encrypted_token = self.encrypt(token, self.TOKEN_KEY, self.TOKEN_IV)

            if not encrypted_token:
                error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
                print(f"[{error_time}] ❌ 请求#{request_id:06d} Token加密失败")
                return {
                    "success": False,
                    "uid": uid,
                    "error": "Token加密失败",
                    "request_id": request_id,
                    "total_duration": time.time() - start_time
                }

            # 盐和请求体
            salt = "a920b7226ea0dac52158deca9baa0a5f"
            timestamp = int(time.time() * 1000)
            request_body = {
                "is_pirated": 0,
                "idfa": "00000000-0000-0000-0000-000000000000",
                "ts": timestamp,
                "is_nim": 1,
                "is_template": 1,
                "req_rand": 9859,
                "con_type": 2,
                "stid": "T/omc0DpXoO9qB2Okv1LRw==",
                "is_simulator": 0,
                "app_id": "1",
                "timet": 1751701302,
                "os": "ios",
                "os_ver": "18.5",
                "udid": "51aff186c5415501d41a898d8781d32a7f115646",
                "appname": "bottle",
                "ver": "7.11.4",
                "token": encrypted_token,
                "body": "今天是 7月 16 日 上午,如果可以和一个名人共进晚餐，你会选谁？为什么？华哥哥吗?",
                "idfv": "77A91C46-52EF-43AE-9BA6-A9D208CEC323",
                "is_jailbroken": 0,
                "app_type": "1",
                "p_model": "iPhone15,2",
                "device_jb": 0,
                "timew": 1751701302,
                "umid": "9429bc136b2290574bbc3a9252eb60b6"
            }

            # 生成签名
            body_str = json.dumps(request_body)
            sign = hashlib.md5((body_str + salt).encode('utf-8')).hexdigest()

            # 准备请求头
            headers = {
                'Content-Type': 'application/json',
                'Sign': sign
            }

            # 发送请求并记录网络耗时
            url = "https://stage-api-meeting.weizhiyanchina.com/bottle/throw"
            network_start = time.time()
            response = requests.post(url, json=request_body, headers=headers, timeout=10)
            network_end = time.time()

            network_duration = network_end - network_start
            response_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]

            if response.status_code == 200:
                # 解密响应数据
                decrypt_start = time.time()
                decrypted_response = self.decrypt(response.text, self.CONTENT_KEY, self.CONTENT_IV)
                decrypt_end = time.time()
                decrypt_duration = decrypt_end - decrypt_start
                total_duration = time.time() - start_time

                if decrypted_response:
                    print(
                        f"[{response_time}] ✅ 请求#{request_id:06d} 成功 | 网络: {network_duration:.3f}s | 解密: {decrypt_duration:.3f}s | 总计: {total_duration:.3f}s | 大小: {len(response.text)}B")
                    return {
                        "success": True,
                        "uid": uid,
                        "response": decrypted_response,
                        "request_id": request_id,
                        "network_duration": network_duration,
                        "decrypt_duration": decrypt_duration,
                        "total_duration": total_duration,
                        "status_code": response.status_code,
                        "response_size": len(response.text)
                    }
                else:
                    print(
                        f"[{response_time}] ❌ 请求#{request_id:06d} 解密失败 | 网络: {network_duration:.3f}s | 总计: {total_duration:.3f}s")
                    return {
                        "success": False,
                        "uid": uid,
                        "error": "响应解密失败",
                        "request_id": request_id,
                        "network_duration": network_duration,
                        "total_duration": total_duration,
                        "status_code": response.status_code
                    }
            else:
                total_duration = time.time() - start_time
                print(
                    f"[{response_time}] ❌ 请求#{request_id:06d} HTTP错误 | 状态码: {response.status_code} | 网络: {network_duration:.3f}s | 总计: {total_duration:.3f}s")
                return {
                    "success": False,
                    "uid": uid,
                    "error": f"HTTP {response.status_code}",
                    "request_id": request_id,
                    "network_duration": network_duration,
                    "total_duration": total_duration,
                    "status_code": response.status_code
                }

        except requests.exceptions.Timeout:
            total_duration = time.time() - start_time
            error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(f"[{error_time}] ⏰ 请求#{request_id:06d} 超时 | 总计: {total_duration:.3f}s")
            return {"success": False, "uid": uid, "error": "请求超时", "request_id": request_id,
                    "total_duration": total_duration}

        except requests.exceptions.ConnectionError:
            total_duration = time.time() - start_time
            error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(f"[{error_time}] 🔌 请求#{request_id:06d} 连接错误 | 总计: {total_duration:.3f}s")
            return {"success": False, "uid": uid, "error": "连接错误", "request_id": request_id,
                    "total_duration": total_duration}

        except Exception as e:
            total_duration = time.time() - start_time
            error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(f"[{error_time}] 💥 请求#{request_id:06d} 异常: {str(e)} | 总计: {total_duration:.3f}s")
            return {"success": False, "uid": uid, "error": str(e), "request_id": request_id,
                    "total_duration": total_duration}


class StressTest:
    def __init__(self, target_qps=200):
        self.api = BottleAPI()
        self.target_qps = target_qps
        self.results = []
        self.lock = threading.Lock()
        self.request_counter = 0

    def worker(self, uid):
        """单个工作线程函数"""
        with self.lock:
            self.request_counter += 1
            request_id = self.request_counter

        start_time = time.time()
        result = self.api.send_message(uid, request_id)
        end_time = time.time()

        # 如果API没有返回duration，使用这里计算的
        if "total_duration" not in result:
            result["total_duration"] = end_time - start_time

        # 保持原有的duration字段兼容性
        result["duration"] = result.get("total_duration", end_time - start_time)

        with self.lock:
            self.results.append(result)

        return result

    def print_progress(self, elapsed_time, sent_requests):
        """打印实时进度"""
        with self.lock:
            completed_requests = len(self.results)
            success_count = sum(1 for r in self.results if r.get("success", False))
            failure_count = completed_requests - success_count
            current_qps = completed_requests / elapsed_time if elapsed_time > 0 else 0
            success_rate = (success_count / completed_requests * 100) if completed_requests > 0 else 0

            # 计算平均响应时间
            durations = [r.get("duration", 0) for r in self.results if "duration" in r]
            avg_duration = statistics.mean(durations) if durations else 0

            print(
                f"📊 [{elapsed_time:.0f}s] 已发送: {sent_requests} | 已完成: {completed_requests} | 成功: {success_count} | 失败: {failure_count} | QPS: {current_qps:.2f} | 成功率: {success_rate:.1f}% | 平均响应: {avg_duration:.3f}s")

    def run_stress_test(self, uid_list, duration_seconds=300):  # 改为5分钟
        """运行压测"""
        print("=" * 80)
        print(f"🎯 开始Bottle API压力测试")
        print(f"📈 目标QPS: {self.target_qps}")
        print(f"⏱️  测试时长: {duration_seconds}秒 ({duration_seconds // 60}分钟)")
        print(f"👥 UID数量: {len(uid_list)}")
        print(f"🔧 并发线程: 100")
        print(f"🕐 开始时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)

        # 计算需要的并发线程数
        max_workers = 100  # 固定使用100个线程

        start_time = time.time()
        request_count = 0
        last_progress_time = 0

        # 计算请求间隔
        request_interval = 1.0 / self.target_qps  # 每个请求的间隔时间

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # 持续发送请求直到达到目标时间
            while time.time() - start_time < duration_seconds:
                batch_start = time.time()
                elapsed = time.time() - start_time

                # 每10秒打印一次进度
                if elapsed - last_progress_time >= 10:
                    self.print_progress(elapsed, request_count)
                    last_progress_time = elapsed

                # 发送一批请求
                futures = []
                batch_size = min(10, max_workers)  # 每批发送10个请求

                for i in range(batch_size):
                    uid = uid_list[(request_count + i) % len(uid_list)]
                    future = executor.submit(self.worker, uid)
                    futures.append(future)
                    request_count += 1

                # 等待这批请求完成
                concurrent.futures.wait(futures, timeout=1.0)

                # 控制请求频率
                batch_time = time.time() - batch_start
                sleep_time = request_interval * batch_size - batch_time
                if sleep_time > 0:
                    time.sleep(sleep_time)

        end_time = time.time()
        actual_duration = end_time - start_time
        actual_qps = request_count / actual_duration

        # 等待所有请求完成
        print(f"\n⏳ 等待剩余请求完成...")
        time.sleep(2)  # 等待2秒让剩余请求完成

        self.print_enhanced_results(request_count, actual_duration, actual_qps)

    def print_enhanced_results(self, total_requests, duration, actual_qps):
        """打印增强版压测结果"""
        print("\n" + "=" * 80)
        print("📊 Bottle API 压力测试详细报告")
        print("=" * 80)

        # 基本统计
        completed_requests = len(self.results)
        success_count = sum(1 for r in self.results if r.get("success", False))
        failure_count = completed_requests - success_count
        success_rate = (success_count / completed_requests * 100) if completed_requests > 0 else 0

        print(f"🕐 测试完成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"⏱️  实际持续时间: {duration:.2f}秒 ({duration / 60:.1f}分钟)")
        print(f"📦 发送请求总数: {total_requests}")
        print(f"📋 完成请求数: {completed_requests}")
        print(f"📈 目标QPS: {self.target_qps}")
        print(f"📊 实际QPS: {actual_qps:.2f}")
        print(f"🎯 QPS达成率: {(actual_qps / self.target_qps) * 100:.2f}%")
        print(f"✅ 成功请求: {success_count}")
        print(f"❌ 失败请求: {failure_count}")
        print(f"📈 成功率: {success_rate:.2f}%")

        # 响应时间统计
        print("\n" + "-" * 60)
        print("⏱️  响应时间详细统计")
        print("-" * 60)

        durations = [r["duration"] for r in self.results if "duration" in r and r.get("success")]
        if durations:
            sorted_durations = sorted(durations)
            p95 = sorted_durations[int(len(sorted_durations) * 0.95)] if sorted_durations else 0
            p99 = sorted_durations[int(len(sorted_durations) * 0.99)] if sorted_durations else 0

            print(f"📊 总响应时间统计:")
            print(f"   平均响应时间: {statistics.mean(durations):.3f}秒")
            print(f"   最小响应时间: {min(durations):.3f}秒")
            print(f"   最大响应时间: {max(durations):.3f}秒")
            print(f"   中位数响应时间: {statistics.median(durations):.3f}秒")
            print(f"   95%分位响应时间: {p95:.3f}秒")
            print(f"   99%分位响应时间: {p99:.3f}秒")

        # 网络响应时间统计
        network_durations = [r.get("network_duration", 0) for r in self.results if
                             "network_duration" in r and r.get("success")]
        if network_durations:
            print(f"\n🌐 网络响应时间 (纯HTTP请求):")
            print(f"   平均网络时间: {statistics.mean(network_durations):.3f}秒")
            print(f"   最小网络时间: {min(network_durations):.3f}秒")
            print(f"   最大网络时间: {max(network_durations):.3f}秒")
            print(f"   中位数网络时间: {statistics.median(network_durations):.3f}秒")

        # 解密时间统计
        decrypt_durations = [r.get("decrypt_duration", 0) for r in self.results if
                             "decrypt_duration" in r and r.get("success")]
        if decrypt_durations:
            print(f"\n🔓 解密处理时间:")
            print(f"   平均解密时间: {statistics.mean(decrypt_durations):.3f}秒")
            print(f"   最大解密时间: {max(decrypt_durations):.3f}秒")

        # HTTP状态码统计
        print("\n" + "-" * 60)
        print("📡 HTTP状态码分布")
        print("-" * 60)
        status_codes = defaultdict(int)
        for result in self.results:
            if "status_code" in result:
                status_codes[result["status_code"]] += 1

        for code, count in sorted(status_codes.items()):
            percentage = (count / completed_requests * 100) if completed_requests > 0 else 0
            status_text = "✅ 成功" if code == 200 else "❌ 错误"
            print(f"   HTTP {code} ({status_text}): {count}次 ({percentage:.1f}%)")

        # 错误统计
        print("\n" + "-" * 60)
        print("❌ 错误类型统计")
        print("-" * 60)
        errors = defaultdict(int)
        for result in self.results:
            if not result.get("success", False) and "error" in result:
                errors[result["error"]] += 1

        if errors:
            for error, count in sorted(errors.items(), key=lambda x: x[1], reverse=True):
                percentage = (count / failure_count * 100) if failure_count > 0 else 0
                print(f"   {error}: {count}次 ({percentage:.1f}%)")
        else:
            print("   🎉 没有错误发生！")

        # 性能评估
        print("\n" + "-" * 60)
        print("🎯 性能评估结果")
        print("-" * 60)

        # 成功率评估
        if success_rate >= 99:
            print("   🟢 成功率评估: 优秀 (≥99%)")
        elif success_rate >= 95:
            print("   🟡 成功率评估: 良好 (≥95%)")
        elif success_rate >= 90:
            print("   🟠 成功率评估: 一般 (≥90%)")
        else:
            print("   🔴 成功率评估: 较差 (<90%)")

        # QPS评估
        qps_achievement = (actual_qps / self.target_qps) * 100
        if qps_achievement >= 95:
            print("   🟢 QPS评估: 达标 (≥95%目标)")
        elif qps_achievement >= 80:
            print("   🟡 QPS评估: 接近目标 (≥80%目标)")
        else:
            print("   🔴 QPS评估: 未达标 (<80%目标)")

        # 响应时间评估
        avg_response = statistics.mean(durations) if durations else 0
        if avg_response <= 1.0:
            print("   🟢 响应时间评估: 快速 (≤1.0s)")
        elif avg_response <= 3.0:
            print("   🟡 响应时间评估: 正常 (≤3.0s)")
        else:
            print("   🔴 响应时间评估: 较慢 (>3.0s)")

        # 响应大小统计
        response_sizes = [r.get("response_size", 0) for r in self.results if "response_size" in r and r.get("success")]
        if response_sizes:
            print(f"\n📦 响应数据大小:")
            print(f"   平均响应大小: {statistics.mean(response_sizes):.0f}字节")
            print(f"   最大响应大小: {max(response_sizes)}字节")
            print(f"   最小响应大小: {min(response_sizes)}字节")

        print("\n" + "=" * 80)
        print(f"📝 报告生成完成 | 生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)


if __name__ == "__main__":
    # 压测配置
    TARGET_QPS = 10  # 目标QPS
    DURATION_SECONDS = 300  # 5分钟 = 300秒

    # 使用你提供的UID列表（可以扩展为完整列表）
    uid_str = "10876645,11209576,10876632,10876642,11209562,10876627,10876661,10876647,11210041,11209995,10876640,11209557,10876361,11209556,10787472,11209512,10876502,10876408,11209563,11209812,10876588,10876222,11209587,10876631,11209567,10876559,10876504,11209584,10876452,11209635,10876569,10876662,10876373,10876530,10876328,11209839,10876500,4434889,3527877,10876609"

    uid_list = [u.strip() for u in uid_str.split(",")]

    # 多线程压测
    stress_test = StressTest(target_qps=TARGET_QPS)
    stress_test.run_stress_test(uid_list, DURATION_SECONDS)