uid_str = "10876645,11209576,10876632,10876642,11209562,10876627,10876661,10876647,11210041,11209995,10876640,11209557,10876361,11209556,10787472,11209512,10876502,10876408,11209563,11209812,10876588,10876222,11209587,10876631,11209567,10876559,10876504,11209584,10876452,11209635,10876569,10876662,10876373,10876530,10876328,11209839,10876500,4434889,3527877,10876609,10876267,10876270,10876487,10876337,10876430,10876347,10876596,11209573,10876213,11209618,10876335,10876228,10876397,10876409,11209988,10876602,10876403,10876383,11209899,10876421,11210096,10876249,11209775,11210064,10876687,11210090,10876351,10876689,11209606,10876707,10876978,11209544,10876562,10876350,10876480,11209721,10876388,11209884,10876555,11210076,10876583,11209582,10876345,11209848,11209996,11209654,10876507,11209912,10876656,11209850,10876762,11209870,11210029,11209772,11209630,11209845,11210013,11209797,11209620,11210030,11210101,11209718,11209824,10876550,11209823,11210010,11209597,10876338,10876683,10876463,10876603,11209616,11209773,11209810,10876524,10876257,11209785,10876247,11209750,10876479,11209626,11209897,10876429,10876445,10876478,10876665,11210069,11209636,10876370,10876339,11209736,11209986,11209651,10876724,10876668,10876410,11210080,11210093,11209771,10876591,11209652,11210002,11209826,10876621,11210070,11210049,11209546,11209893,10876741,11209792,10876705,10876786,11209744,11209742,10876581,11209543,11209628,11209818,11210012,10876396,10876441,11210048,11209533,11209727,10876691,11209613,10876385,10876521,10876744,10876605,10876652,11209523,11209728,11209622,10876680,11209719,10876404,11209632,10876513,11209595,11210066,10876574,11209639,11209781,11210081,11210094,10876634,10876377,11209869,10876241,10876437,11209538,10876497,11209642,10876620,11209895,10876231,11209529,11209564,10876425,11210019,11209600,11209604,11209774,10876531,11209548,11209814,10876343,10876382,11209649,11209627,11209745,11209950,11209789,10876696,10787566,10876254,11209634,11209816,11209804,10876367,11210062,11209982,10876613,11210005,11209609,10876378,10876433,11209653,10876553,11209752,10876575,11209534,11209953,10876459,11209872,10876365,11209917,11209984,11209948,10876606,11209770,11209608,11209515,10876571,11209553,10876607,11209879,10876535,11209813,11210043,11209648,10876243,10876333,10876245,10876970,11209907,11209778,11209808,11209629,10876789,10876564,11210024,11209720,11209934,11209625,10876616,11209866,10876363,11210099,10700301,10683240,10876793,7071509,10876330,10876475,11209821,11209754,10876380,10876694,10876590,11210007,10876560,10876375,10876255,11209880,11209882,11209838,11209769,10876438,10876686,10876516,10876675,11209840,10876677,11209947,11209550,10876412,10876400,10876577,11209566,10876643,10876658,10876519,10876641,10876838,10876357,10876597,10876649,11209561,11209586,10876458,10876444,10876636,10876844,11209545,11209565,10876527,11209531,10876332,10876646,11209558,11210003,11209575,10876576,10876628,10410388,11209637,10185257,11209552,10876465,10876651,11209555,11209585,10876558,10585795,10681328,10877062,10876639,10876391,10876644,10876648,10876348,10876654,10876679,11209559,10876499,10876269,10876489,10876493,10876488,10876271,11209998,10876885,10876871,11209815,10876520,11209560,11209578,10787359,11209711,10877003,10876791,11209594,11210008,11209938,10876761,11209571,10876943,11209670,10876948,11209540,10876947,11209864,10876469,10876716,11209579,11210027,10876635,10876601,11209737,10876424,10876889,10877051,10876376,10876972,10877014,10876392,11209676,10877045,10876490,11209795,10876374,10876473,10876897,10877066,10876915,10877077,10876788,10877068,11209990,11209596,11209583,10876670,10876608,10876824,10876442,10877058,11209963,10876501,10876739,10876863,10876790,10876923,11210053,11209647,11209908,11210067,10876580,10876809,11209787,10877000,10876448,10876782,11210052,10876905,10876394,11209999,11210015,10876913,10876259,11209964,11209656,10876881,10876618,10876693,10876812,10876964,11209599,11210102,10876892,10876667,10876223,10876354,11209945,10876399,10876485,10876787,11209519,11209847,11209699,10876894,10876870,10877076,10877028,10876842,10876470,11209876,11209674,10876912,11210047,11209621,10876857,10876922,10876867,11209551,11209901,10787567,11209717,11209521,11209532,10876811,10876921,11209708,11210057,10876614,10876880,10876785,11209655,11210033,11209692,11209958,11209807,10876714,10876733,11209598,10876406,10877038,10876803,10876678,11209881,11210091,10876831,10877007,11209985,10876460,10876704,11210004,10876719,10876671,10876910,10876422,11209715,10876882,11209530,10877085,10876364,10876834,11210056,10876983,10876991,10877033,11209765,11209640,10876723,10876589,10876988,10876895,10876248,11210025,10876925,11209581,10877064,11209592,10876936,11210065,11209614,10876956,10876563,10876884,10876759,10877012,10877063,11210110,10876990,10876509,11209878,11209516,11209867,10876466,10876240,10876258,10876768,11209940,10876953,10876823,11210034,11209883,10876751,11209524,10876402,11209791,10876623,10876669,10877043,11210039,10876708,10876850,10876703,11209607,11209709,11209589,10876801,10877042,11209902,10876434,10876341,10876548,10876579,10876384,10877086,11210079,10876977,10876800,10876529,11210087,11209991,11209661,10876810,11210092,10876989,11209536,11209677,11209577,10876969,11209777,10876660,10876512,10876663,10876847,10877029,10876931,10876549,10876934,11209685,10876945,10876930,11209766,11209680,10876536,10876538,11209660,11209638,10876518,10876227,10876547,10877050,10876815,10876584"


import json
import time
import hashlib
import base64
import requests
import threading
import concurrent.futures
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from collections import defaultdict
import statistics
from datetime import datetime


class BottleAPI:
    # æµ‹è¯•ç¯å¢ƒ
    TOKEN_KEY = b'358d71c554ae78914fece40609aad77b'
    TOKEN_IV = b'F3a22EcceB2e0t13'
    CONTENT_KEY = b'75fa6cf7300033b477f5644110b8fcd7'
    CONTENT_IV = b'907AcdEf2fCb17fb'

    @staticmethod
    def encrypt(text: str, key: bytes, iv: bytes) -> str:
        """AES CBC æ¨¡å¼åŠ å¯†"""
        try:
            text = text.encode('utf-8')
            cipher = AES.new(key, AES.MODE_CBC, iv)
            encrypted = cipher.encrypt(pad(text, AES.block_size))
            return base64.b64encode(encrypted).decode('utf-8')
        except Exception as e:
            print(f"âŒ åŠ å¯†é”™è¯¯: {e}")
            return None

    @staticmethod
    def decrypt(encrypted_text: str, key: bytes, iv: bytes) -> str:
        """AES CBC æ¨¡å¼è§£å¯†"""
        try:
            encrypted = base64.b64decode(encrypted_text)
            cipher = AES.new(key, AES.MODE_CBC, iv)
            decrypted = unpad(cipher.decrypt(encrypted), AES.block_size)
            return decrypted.decode('utf-8')
        except Exception as e:
            print(f"âŒ è§£å¯†é”™è¯¯: {e}")
            return None

    def send_message(self, uid, request_id=None):
        if request_id is None:
            request_id = int(time.time() * 1000000) % 1000000

        # è®°å½•å¼€å§‹æ—¶é—´
        start_time = time.time()
        current_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        print(f"[{current_time}] ğŸš€ è¯·æ±‚#{request_id:06d} å¼€å§‹ | UID: {uid}")

        try:
            # åŠ å¯†token
            token = json.dumps({"uid": uid})
            encrypted_token = self.encrypt(token, self.TOKEN_KEY, self.TOKEN_IV)

            if not encrypted_token:
                error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
                print(f"[{error_time}] âŒ è¯·æ±‚#{request_id:06d} TokenåŠ å¯†å¤±è´¥")
                return {
                    "success": False,
                    "uid": uid,
                    "error": "TokenåŠ å¯†å¤±è´¥",
                    "request_id": request_id,
                    "total_duration": time.time() - start_time
                }

            # ç›å’Œè¯·æ±‚ä½“
            salt = "a920b7226ea0dac52158deca9baa0a5f"
            timestamp = int(time.time() * 1000)
            request_body = {
                "is_pirated": 0,
                "idfa": "00000000-0000-0000-0000-000000000000",
                "ts": timestamp,
                "is_nim": 1,
                "is_template": 1,
                "req_rand": 9859,
                "con_type": 2,
                "stid": "T/omc0DpXoO9qB2Okv1LRw==",
                "is_simulator": 0,
                "app_id": "1",
                "timet": 1751701302,
                "os": "ios",
                "os_ver": "18.5",
                "udid": "51aff186c5415501d41a898d8781d32a7f115646",
                "appname": "bottle",
                "ver": "7.11.4",
                "token": encrypted_token,
                "body": "ä»Šå¤©æ˜¯ 7æœˆ 16 æ—¥ ä¸Šåˆ,å¦‚æœå¯ä»¥å’Œä¸€ä¸ªåäººå…±è¿›æ™šé¤ï¼Œä½ ä¼šé€‰è°ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿåå“¥å“¥å—?",
                "idfv": "77A91C46-52EF-43AE-9BA6-A9D208CEC323",
                "is_jailbroken": 0,
                "app_type": "1",
                "p_model": "iPhone15,2",
                "device_jb": 0,
                "timew": 1751701302,
                "umid": "9429bc136b2290574bbc3a9252eb60b6"
            }

            # ç”Ÿæˆç­¾å
            body_str = json.dumps(request_body)
            sign = hashlib.md5((body_str + salt).encode('utf-8')).hexdigest()

            # å‡†å¤‡è¯·æ±‚å¤´
            headers = {
                'Content-Type': 'application/json',
                'Sign': sign
            }

            # å‘é€è¯·æ±‚å¹¶è®°å½•ç½‘ç»œè€—æ—¶
            url = "https://stage-api-meeting.weizhiyanchina.com/bottle/throw"
            network_start = time.time()
            response = requests.post(url, json=request_body, headers=headers, timeout=10)
            network_end = time.time()

            network_duration = network_end - network_start
            response_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]

            if response.status_code == 200:
                # è§£å¯†å“åº”æ•°æ®
                decrypt_start = time.time()
                decrypted_response = self.decrypt(response.text, self.CONTENT_KEY, self.CONTENT_IV)
                decrypt_end = time.time()
                decrypt_duration = decrypt_end - decrypt_start
                total_duration = time.time() - start_time

                if decrypted_response:
                    print(
                        f"[{response_time}] âœ… è¯·æ±‚#{request_id:06d} æˆåŠŸ | ç½‘ç»œ: {network_duration:.3f}s | è§£å¯†: {decrypt_duration:.3f}s | æ€»è®¡: {total_duration:.3f}s | å¤§å°: {len(response.text)}B")
                    return {
                        "success": True,
                        "uid": uid,
                        "response": decrypted_response,
                        "request_id": request_id,
                        "network_duration": network_duration,
                        "decrypt_duration": decrypt_duration,
                        "total_duration": total_duration,
                        "status_code": response.status_code,
                        "response_size": len(response.text)
                    }
                else:
                    print(
                        f"[{response_time}] âŒ è¯·æ±‚#{request_id:06d} è§£å¯†å¤±è´¥ | ç½‘ç»œ: {network_duration:.3f}s | æ€»è®¡: {total_duration:.3f}s")
                    return {
                        "success": False,
                        "uid": uid,
                        "error": "å“åº”è§£å¯†å¤±è´¥",
                        "request_id": request_id,
                        "network_duration": network_duration,
                        "total_duration": total_duration,
                        "status_code": response.status_code
                    }
            else:
                total_duration = time.time() - start_time
                print(
                    f"[{response_time}] âŒ è¯·æ±‚#{request_id:06d} HTTPé”™è¯¯ | çŠ¶æ€ç : {response.status_code} | ç½‘ç»œ: {network_duration:.3f}s | æ€»è®¡: {total_duration:.3f}s")
                return {
                    "success": False,
                    "uid": uid,
                    "error": f"HTTP {response.status_code}",
                    "request_id": request_id,
                    "network_duration": network_duration,
                    "total_duration": total_duration,
                    "status_code": response.status_code
                }

        except requests.exceptions.Timeout:
            total_duration = time.time() - start_time
            error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(f"[{error_time}] â° è¯·æ±‚#{request_id:06d} è¶…æ—¶ | æ€»è®¡: {total_duration:.3f}s")
            return {"success": False, "uid": uid, "error": "è¯·æ±‚è¶…æ—¶", "request_id": request_id,
                    "total_duration": total_duration}

        except requests.exceptions.ConnectionError:
            total_duration = time.time() - start_time
            error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(f"[{error_time}] ğŸ”Œ è¯·æ±‚#{request_id:06d} è¿æ¥é”™è¯¯ | æ€»è®¡: {total_duration:.3f}s")
            return {"success": False, "uid": uid, "error": "è¿æ¥é”™è¯¯", "request_id": request_id,
                    "total_duration": total_duration}

        except Exception as e:
            total_duration = time.time() - start_time
            error_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(f"[{error_time}] ğŸ’¥ è¯·æ±‚#{request_id:06d} å¼‚å¸¸: {str(e)} | æ€»è®¡: {total_duration:.3f}s")
            return {"success": False, "uid": uid, "error": str(e), "request_id": request_id,
                    "total_duration": total_duration}


class StressTest:
    def __init__(self, target_qps=200):
        self.api = BottleAPI()
        self.target_qps = target_qps
        self.results = []
        self.lock = threading.Lock()
        self.request_counter = 0

    def worker(self, uid):
        """å•ä¸ªå·¥ä½œçº¿ç¨‹å‡½æ•°"""
        with self.lock:
            self.request_counter += 1
            request_id = self.request_counter

        start_time = time.time()
        result = self.api.send_message(uid, request_id)
        end_time = time.time()

        # å¦‚æœAPIæ²¡æœ‰è¿”å›durationï¼Œä½¿ç”¨è¿™é‡Œè®¡ç®—çš„
        if "total_duration" not in result:
            result["total_duration"] = end_time - start_time

        # ä¿æŒåŸæœ‰çš„durationå­—æ®µå…¼å®¹æ€§
        result["duration"] = result.get("total_duration", end_time - start_time)

        with self.lock:
            self.results.append(result)

        return result

    def print_progress(self, elapsed_time, sent_requests):
        """æ‰“å°å®æ—¶è¿›åº¦"""
        with self.lock:
            completed_requests = len(self.results)
            success_count = sum(1 for r in self.results if r.get("success", False))
            failure_count = completed_requests - success_count
            current_qps = completed_requests / elapsed_time if elapsed_time > 0 else 0
            success_rate = (success_count / completed_requests * 100) if completed_requests > 0 else 0

            # è®¡ç®—å¹³å‡å“åº”æ—¶é—´
            durations = [r.get("duration", 0) for r in self.results if "duration" in r]
            avg_duration = statistics.mean(durations) if durations else 0

            print(
                f"ğŸ“Š [{elapsed_time:.0f}s] å·²å‘é€: {sent_requests} | å·²å®Œæˆ: {completed_requests} | æˆåŠŸ: {success_count} | å¤±è´¥: {failure_count} | QPS: {current_qps:.2f} | æˆåŠŸç‡: {success_rate:.1f}% | å¹³å‡å“åº”: {avg_duration:.3f}s")

    def run_stress_test(self, uid_list, duration_seconds=300):  # æ”¹ä¸º5åˆ†é’Ÿ
        """è¿è¡Œå‹æµ‹"""
        print("=" * 80)
        print(f"ğŸ¯ å¼€å§‹Bottle APIå‹åŠ›æµ‹è¯•")
        print(f"ğŸ“ˆ ç›®æ ‡QPS: {self.target_qps}")
        print(f"â±ï¸  æµ‹è¯•æ—¶é•¿: {duration_seconds}ç§’ ({duration_seconds // 60}åˆ†é’Ÿ)")
        print(f"ğŸ‘¥ UIDæ•°é‡: {len(uid_list)}")
        print(f"ğŸ”§ å¹¶å‘çº¿ç¨‹: 100")
        print(f"ğŸ• å¼€å§‹æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)

        # è®¡ç®—éœ€è¦çš„å¹¶å‘çº¿ç¨‹æ•°
        max_workers = 100  # å›ºå®šä½¿ç”¨100ä¸ªçº¿ç¨‹

        start_time = time.time()
        request_count = 0
        last_progress_time = 0

        # è®¡ç®—è¯·æ±‚é—´éš”
        request_interval = 1.0 / self.target_qps  # æ¯ä¸ªè¯·æ±‚çš„é—´éš”æ—¶é—´

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            # æŒç»­å‘é€è¯·æ±‚ç›´åˆ°è¾¾åˆ°ç›®æ ‡æ—¶é—´
            while time.time() - start_time < duration_seconds:
                batch_start = time.time()
                elapsed = time.time() - start_time

                # æ¯10ç§’æ‰“å°ä¸€æ¬¡è¿›åº¦
                if elapsed - last_progress_time >= 10:
                    self.print_progress(elapsed, request_count)
                    last_progress_time = elapsed

                # å‘é€ä¸€æ‰¹è¯·æ±‚
                futures = []
                batch_size = min(10, max_workers)  # æ¯æ‰¹å‘é€10ä¸ªè¯·æ±‚

                for i in range(batch_size):
                    uid = uid_list[(request_count + i) % len(uid_list)]
                    future = executor.submit(self.worker, uid)
                    futures.append(future)
                    request_count += 1

                # ç­‰å¾…è¿™æ‰¹è¯·æ±‚å®Œæˆ
                concurrent.futures.wait(futures, timeout=1.0)

                # æ§åˆ¶è¯·æ±‚é¢‘ç‡
                batch_time = time.time() - batch_start
                sleep_time = request_interval * batch_size - batch_time
                if sleep_time > 0:
                    time.sleep(sleep_time)

        end_time = time.time()
        actual_duration = end_time - start_time
        actual_qps = request_count / actual_duration

        # ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
        print(f"\nâ³ ç­‰å¾…å‰©ä½™è¯·æ±‚å®Œæˆ...")
        time.sleep(2)  # ç­‰å¾…2ç§’è®©å‰©ä½™è¯·æ±‚å®Œæˆ

        self.print_enhanced_results(request_count, actual_duration, actual_qps)

    def print_enhanced_results(self, total_requests, duration, actual_qps):
        """æ‰“å°å¢å¼ºç‰ˆå‹æµ‹ç»“æœ"""
        print("\n" + "=" * 80)
        print("ğŸ“Š Bottle API å‹åŠ›æµ‹è¯•è¯¦ç»†æŠ¥å‘Š")
        print("=" * 80)

        # åŸºæœ¬ç»Ÿè®¡
        completed_requests = len(self.results)
        success_count = sum(1 for r in self.results if r.get("success", False))
        failure_count = completed_requests - success_count
        success_rate = (success_count / completed_requests * 100) if completed_requests > 0 else 0

        print(f"ğŸ• æµ‹è¯•å®Œæˆæ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"â±ï¸  å®é™…æŒç»­æ—¶é—´: {duration:.2f}ç§’ ({duration / 60:.1f}åˆ†é’Ÿ)")
        print(f"ğŸ“¦ å‘é€è¯·æ±‚æ€»æ•°: {total_requests}")
        print(f"ğŸ“‹ å®Œæˆè¯·æ±‚æ•°: {completed_requests}")
        print(f"ğŸ“ˆ ç›®æ ‡QPS: {self.target_qps}")
        print(f"ğŸ“Š å®é™…QPS: {actual_qps:.2f}")
        print(f"ğŸ¯ QPSè¾¾æˆç‡: {(actual_qps / self.target_qps) * 100:.2f}%")
        print(f"âœ… æˆåŠŸè¯·æ±‚: {success_count}")
        print(f"âŒ å¤±è´¥è¯·æ±‚: {failure_count}")
        print(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.2f}%")

        # å“åº”æ—¶é—´ç»Ÿè®¡
        print("\n" + "-" * 60)
        print("â±ï¸  å“åº”æ—¶é—´è¯¦ç»†ç»Ÿè®¡")
        print("-" * 60)

        durations = [r["duration"] for r in self.results if "duration" in r and r.get("success")]
        if durations:
            sorted_durations = sorted(durations)
            p95 = sorted_durations[int(len(sorted_durations) * 0.95)] if sorted_durations else 0
            p99 = sorted_durations[int(len(sorted_durations) * 0.99)] if sorted_durations else 0

            print(f"ğŸ“Š æ€»å“åº”æ—¶é—´ç»Ÿè®¡:")
            print(f"   å¹³å‡å“åº”æ—¶é—´: {statistics.mean(durations):.3f}ç§’")
            print(f"   æœ€å°å“åº”æ—¶é—´: {min(durations):.3f}ç§’")
            print(f"   æœ€å¤§å“åº”æ—¶é—´: {max(durations):.3f}ç§’")
            print(f"   ä¸­ä½æ•°å“åº”æ—¶é—´: {statistics.median(durations):.3f}ç§’")
            print(f"   95%åˆ†ä½å“åº”æ—¶é—´: {p95:.3f}ç§’")
            print(f"   99%åˆ†ä½å“åº”æ—¶é—´: {p99:.3f}ç§’")

        # ç½‘ç»œå“åº”æ—¶é—´ç»Ÿè®¡
        network_durations = [r.get("network_duration", 0) for r in self.results if
                             "network_duration" in r and r.get("success")]
        if network_durations:
            print(f"\nğŸŒ ç½‘ç»œå“åº”æ—¶é—´ (çº¯HTTPè¯·æ±‚):")
            print(f"   å¹³å‡ç½‘ç»œæ—¶é—´: {statistics.mean(network_durations):.3f}ç§’")
            print(f"   æœ€å°ç½‘ç»œæ—¶é—´: {min(network_durations):.3f}ç§’")
            print(f"   æœ€å¤§ç½‘ç»œæ—¶é—´: {max(network_durations):.3f}ç§’")
            print(f"   ä¸­ä½æ•°ç½‘ç»œæ—¶é—´: {statistics.median(network_durations):.3f}ç§’")

        # è§£å¯†æ—¶é—´ç»Ÿè®¡
        decrypt_durations = [r.get("decrypt_duration", 0) for r in self.results if
                             "decrypt_duration" in r and r.get("success")]
        if decrypt_durations:
            print(f"\nğŸ”“ è§£å¯†å¤„ç†æ—¶é—´:")
            print(f"   å¹³å‡è§£å¯†æ—¶é—´: {statistics.mean(decrypt_durations):.3f}ç§’")
            print(f"   æœ€å¤§è§£å¯†æ—¶é—´: {max(decrypt_durations):.3f}ç§’")

        # HTTPçŠ¶æ€ç ç»Ÿè®¡
        print("\n" + "-" * 60)
        print("ğŸ“¡ HTTPçŠ¶æ€ç åˆ†å¸ƒ")
        print("-" * 60)
        status_codes = defaultdict(int)
        for result in self.results:
            if "status_code" in result:
                status_codes[result["status_code"]] += 1

        for code, count in sorted(status_codes.items()):
            percentage = (count / completed_requests * 100) if completed_requests > 0 else 0
            status_text = "âœ… æˆåŠŸ" if code == 200 else "âŒ é”™è¯¯"
            print(f"   HTTP {code} ({status_text}): {count}æ¬¡ ({percentage:.1f}%)")

        # é”™è¯¯ç»Ÿè®¡
        print("\n" + "-" * 60)
        print("âŒ é”™è¯¯ç±»å‹ç»Ÿè®¡")
        print("-" * 60)
        errors = defaultdict(int)
        for result in self.results:
            if not result.get("success", False) and "error" in result:
                errors[result["error"]] += 1

        if errors:
            for error, count in sorted(errors.items(), key=lambda x: x[1], reverse=True):
                percentage = (count / failure_count * 100) if failure_count > 0 else 0
                print(f"   {error}: {count}æ¬¡ ({percentage:.1f}%)")
        else:
            print("   ğŸ‰ æ²¡æœ‰é”™è¯¯å‘ç”Ÿï¼")

        # æ€§èƒ½è¯„ä¼°
        print("\n" + "-" * 60)
        print("ğŸ¯ æ€§èƒ½è¯„ä¼°ç»“æœ")
        print("-" * 60)

        # æˆåŠŸç‡è¯„ä¼°
        if success_rate >= 99:
            print("   ğŸŸ¢ æˆåŠŸç‡è¯„ä¼°: ä¼˜ç§€ (â‰¥99%)")
        elif success_rate >= 95:
            print("   ğŸŸ¡ æˆåŠŸç‡è¯„ä¼°: è‰¯å¥½ (â‰¥95%)")
        elif success_rate >= 90:
            print("   ğŸŸ  æˆåŠŸç‡è¯„ä¼°: ä¸€èˆ¬ (â‰¥90%)")
        else:
            print("   ğŸ”´ æˆåŠŸç‡è¯„ä¼°: è¾ƒå·® (<90%)")

        # QPSè¯„ä¼°
        qps_achievement = (actual_qps / self.target_qps) * 100
        if qps_achievement >= 95:
            print("   ğŸŸ¢ QPSè¯„ä¼°: è¾¾æ ‡ (â‰¥95%ç›®æ ‡)")
        elif qps_achievement >= 80:
            print("   ğŸŸ¡ QPSè¯„ä¼°: æ¥è¿‘ç›®æ ‡ (â‰¥80%ç›®æ ‡)")
        else:
            print("   ğŸ”´ QPSè¯„ä¼°: æœªè¾¾æ ‡ (<80%ç›®æ ‡)")

        # å“åº”æ—¶é—´è¯„ä¼°
        avg_response = statistics.mean(durations) if durations else 0
        if avg_response <= 1.0:
            print("   ğŸŸ¢ å“åº”æ—¶é—´è¯„ä¼°: å¿«é€Ÿ (â‰¤1.0s)")
        elif avg_response <= 3.0:
            print("   ğŸŸ¡ å“åº”æ—¶é—´è¯„ä¼°: æ­£å¸¸ (â‰¤3.0s)")
        else:
            print("   ğŸ”´ å“åº”æ—¶é—´è¯„ä¼°: è¾ƒæ…¢ (>3.0s)")

        # å“åº”å¤§å°ç»Ÿè®¡
        response_sizes = [r.get("response_size", 0) for r in self.results if "response_size" in r and r.get("success")]
        if response_sizes:
            print(f"\nğŸ“¦ å“åº”æ•°æ®å¤§å°:")
            print(f"   å¹³å‡å“åº”å¤§å°: {statistics.mean(response_sizes):.0f}å­—èŠ‚")
            print(f"   æœ€å¤§å“åº”å¤§å°: {max(response_sizes)}å­—èŠ‚")
            print(f"   æœ€å°å“åº”å¤§å°: {min(response_sizes)}å­—èŠ‚")

        print("\n" + "=" * 80)
        print(f"ğŸ“ æŠ¥å‘Šç”Ÿæˆå®Œæˆ | ç”Ÿæˆæ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)


if __name__ == "__main__":
    # å‹æµ‹é…ç½®
    TARGET_QPS = 10  # ç›®æ ‡QPS
    DURATION_SECONDS = 300  # 5åˆ†é’Ÿ = 300ç§’

    # ä½¿ç”¨ä½ æä¾›çš„UIDåˆ—è¡¨ï¼ˆå¯ä»¥æ‰©å±•ä¸ºå®Œæ•´åˆ—è¡¨ï¼‰
    uid_str = "10876645,11209576,10876632,10876642,11209562,10876627,10876661,10876647,11210041,11209995,10876640,11209557,10876361,11209556,10787472,11209512,10876502,10876408,11209563,11209812,10876588,10876222,11209587,10876631,11209567,10876559,10876504,11209584,10876452,11209635,10876569,10876662,10876373,10876530,10876328,11209839,10876500,4434889,3527877,10876609"

    uid_list = [u.strip() for u in uid_str.split(",")]

    # å¤šçº¿ç¨‹å‹æµ‹
    stress_test = StressTest(target_qps=TARGET_QPS)
    stress_test.run_stress_test(uid_list, DURATION_SECONDS)